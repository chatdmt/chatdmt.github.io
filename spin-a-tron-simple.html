<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Metatron Cube — Mobile & Desktop</title>
  <style>
    body {
      margin: 0;
      background: #050505;
      overflow: hidden;
    }
    #metatron-container {
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
</head>
<body>
<div id="metatron-container"></div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
(function() {
  const container = document.getElementById('metatron-container');

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050505);

  // ----- CAMERA -----
  const worldSize = 2.2;
  const camera = new THREE.OrthographicCamera(
    -worldSize, worldSize,
     worldSize, -worldSize,
    0.1, 100
  );
  camera.position.set(0,0,5);
  camera.lookAt(0,0,0);

  let renderer = new THREE.WebGLRenderer({ antialias: true });

  // ----- TOUCH DETECTION -----
  const isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

  // ----- SAFE PIXEL RATIO (CAP AT 2x TO AVOID iOS CRASHES) -----
  const basePR = window.devicePixelRatio || 1;
  const safePR = Math.min(basePR, 3);  // cap at 2x
  renderer.setPixelRatio(safePR);

  container.appendChild(renderer.domElement);

  // ---------- GLOBAL ROTATION + INERTIA ----------
  let angleX = 30.0;
  let angleY = 30.0;

  const mouseSensitivity = 0.4;

  let mouseDown = false;
  let lastMouseX = null;
  let lastMouseY = null;

  let velX = 0;
  let velY = 0;
  const damping = 0.94;

  let lockedToVertex = false;

  // ---------- GEOMETRY ----------
  const baseVertices = [
    [-1,-1,-1],[1,-1,-1],
    [1,1,-1],[-1,1,-1],
    [-1,-1,1],[1,-1,1],
    [1,1,1],[-1,1,1]
  ];

  const cubeEdges = [
    [0,1],[1,2],[2,3],[3,0],
    [4,5],[5,6],[6,7],[7,4],
    [0,4],[1,5],[2,6],[3,7]
  ];

  const cubeFaces = [
    [0,1,2,3],
    [4,5,6,7],
    [0,1,5,4],
    [3,2,6,7],
    [0,3,7,4],
    [1,2,6,5]
  ];

  const cubeScales = [1.0, 1/Math.sqrt(2), 0.5];
  const outerScale = cubeScales[0];
  const innerScale = cubeScales[2];

  function scaledVertices(scale) {
    return baseVertices.map(v => [v[0]*scale, v[1]*scale, v[2]*scale]);
  }

  function faceCenters(verts) {
    const centers = [];
    for (const f of cubeFaces) {
      let sx=0, sy=0, sz=0;
      for (const i of f) {
        const v = verts[i];
        sx += v[0]; sy += v[1]; sz += v[2];
      }
      centers.push([sx/4, sy/4, sz/4]);
    }
    return centers;
  }

  // ---------- BUILD LINE GEOMETRY ----------
  const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });

  const allPositions = [];

  function addCube(scale) {
    const v = scaledVertices(scale);
    for (const [a,b] of cubeEdges) {
      const A=v[a], B=v[b];
      allPositions.push(A[0],A[1],A[2], B[0],B[1],B[2]);
    }
    for (const f of cubeFaces) {
      const [a,b,c,d] = f;
      const A=v[a], B=v[b], C=v[c], D=v[d];
      allPositions.push(A[0],A[1],A[2], C[0],C[1],C[2]);
      allPositions.push(B[0],B[1],B[2], D[0],D[1],D[2]);
    }
  }

  function addOctahedron() {
    const v = scaledVertices(outerScale);
    const centers = faceCenters(v);
    const opp = {0:1,1:0,2:3,3:2,4:5,5:4};

    for (let i=0;i<6;i++)
      for (let j=i+1;j<6;j++)
        if (opp[i] !== j) {
          const A=centers[i], B=centers[j];
          allPositions.push(A[0],A[1],A[2], B[0],B[1],B[2]);
        }
  }

  function addPyramids() {
    const v = scaledVertices(outerScale);
    const centers = faceCenters(v);
    const opp = {0:1,1:0,2:3,3:2,4:5,5:4};

    for (let fi=0; fi<6; fi++) {
      const face = cubeFaces[fi];
      const apex = centers[opp[fi]];
      for (const vi of face) {
        const A = v[vi];
        allPositions.push(A[0],A[1],A[2], apex[0],apex[1],apex[2]);
      }
    }
  }

  addCube(outerScale);
  addOctahedron();
  addPyramids();

  const lineGeom = new THREE.BufferGeometry();
  lineGeom.setAttribute("position", new THREE.Float32BufferAttribute(allPositions, 3));
  const lineMesh = new THREE.LineSegments(lineGeom, lineMaterial);

  const cubeGroup = new THREE.Group();
  cubeGroup.add(lineMesh);
  scene.add(cubeGroup);

  // ---------- BILLBOARD CIRCLES ----------
  const circleMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
  const circleRadius = 0.4;
  const circleSeg = 96;

  function circleGeom(r,seg) {
    const pts=[];
    for(let i=0;i<seg;i++){
      const t=2*Math.PI*i/seg;
      pts.push(r*Math.cos(t), r*Math.sin(t), 0);
    }
    const g=new THREE.BufferGeometry();
    g.setAttribute("position", new THREE.Float32BufferAttribute(pts,3));
    return g;
  }

  const circleG = circleGeom(circleRadius, circleSeg);

  const outerVerts = scaledVertices(outerScale);
  const innerVerts = scaledVertices(innerScale);
  const faceCentersOuter = faceCenters(outerVerts);

  const outerCircles = [];
  const innerCircles = [];

  for (let i=0;i<outerVerts.length;i++){
    const c=new THREE.LineLoop(circleG, circleMaterial);
    scene.add(c); outerCircles.push(c);
  }
  for (let i=0;i<innerVerts.length;i++){
    const c=new THREE.LineLoop(circleG, circleMaterial);
    scene.add(c); innerCircles.push(c);
  }

  // ---------- ANGLE + DRIFT MATH ----------
  function rotationMatrix(ax,ay){
    const AX=THREE.MathUtils.degToRad(ax);
    const AY=THREE.MathUtils.degToRad(ay);
    const sx=Math.sin(AX), cx=Math.cos(AX);
    const sy=Math.sin(AY), cy=Math.cos(AY);
    return [
      [ cy,0,-sy ],
      [ sy*sx, cx, cy*sx ],
      [ sy*cx,-sx, cy*cx]
    ];
  }

  function rot(M, v){
    const x=v[0],y=v[1],z=v[2];
    return [
      M[0][0]*x + M[0][1]*y + M[0][2]*z,
      M[1][0]*x + M[1][1]*y + M[1][2]*z,
      M[2][0]*x + M[2][1]*y + M[2][2]*z
    ];
  }

  function bestAngle(ax, ay) {
    const M = rotationMatrix(ax,ay);
    let best = Infinity;

    function process(v){
      let [x,y,z] = rot(M,v);
      const L=Math.sqrt(x*x+y*y+z*z);
      x/=L; y/=L; z/=L;
      const dot = Math.max(-1, Math.min(1, z));
      const ang = Math.acos(dot);
      if (ang < best) best = ang;
    }

    for(const v of outerVerts) process(v);
    for(const c of faceCentersOuter) process(c);

    return best;
  }

  function isAligned(ax,ay){
    return bestAngle(ax,ay) <= THREE.MathUtils.degToRad(5);
  }

  // ---------- DESKTOP POINTER EVENTS ----------
  renderer.domElement.addEventListener("pointerdown", e=>{
    if(isTouch) return;
    mouseDown=true;
    lastMouseX=e.clientX; lastMouseY=e.clientY;
    velX=0; velY=0;
  });

  window.addEventListener("pointerup", ()=>{
    if(isTouch) return;
    mouseDown=false;
    lastMouseX=null; lastMouseY=null;
  });

  renderer.domElement.addEventListener("pointermove", e=>{
    if(isTouch) return;
    if(!mouseDown) return;

    const dx=e.clientX-lastMouseX;
    const dy=e.clientY-lastMouseY;
    lastMouseX=e.clientX; lastMouseY=e.clientY;

    const dAX=dy*mouseSensitivity;
    const dAY=dx*mouseSensitivity;

    angleX+=dAX;
    angleY+=dAY;
    velX=dAX*0.5;
    velY=dAY*0.5;
  });

  // ---------- MOBILE TOUCH EVENTS ----------
  renderer.domElement.addEventListener("touchstart", e=>{
    if(!isTouch) return;
    const t=e.touches[0];
    lastMouseX=t.clientX;
    lastMouseY=t.clientY;
    mouseDown=true;
    velX=0; velY=0;
  }, {passive:true});

  renderer.domElement.addEventListener("touchmove", e=>{
    if(!isTouch) return;
    const t=e.touches[0];
    const dx=t.clientX-lastMouseX;
    const dy=t.clientY-lastMouseY;
    lastMouseX=t.clientX;
    lastMouseY=t.clientY;

    const dAX=dy*mouseSensitivity;
    const dAY=dx*mouseSensitivity;

    angleX+=dAX;
    angleY+=dAY;

    velX=dAX*0.5;
    velY=dAY*0.5;
  }, {passive:true});

  renderer.domElement.addEventListener("touchend", ()=>{
    if(!isTouch) return;
    mouseDown=false;
    lastMouseX=null;
    lastMouseY=null;
  });

  // ---------- DRIFT (15°→0°) + LOCK ----------
  function applyDrift(){
    const ang0 = bestAngle(angleX, angleY);
    const lockTh = THREE.MathUtils.degToRad(0.01);
    const maxActive = THREE.MathUtils.degToRad(15);

    if (lockedToVertex) {
      if (ang0 >= maxActive) lockedToVertex = false;
      else return;
    }

    if (ang0 <= lockTh) {
      velX=0; velY=0;
      lockedToVertex = true;
      return;
    }

    if (ang0 >= maxActive) return;

    const probe = 0.5;
    const step  = 0.6;

    const angPx = bestAngle(angleX+probe, angleY);
    const angMx = bestAngle(angleX-probe, angleY);
    let dx = 0;
    if (angPx < ang0 || angMx < ang0)
      dx = (angPx < angMx) ? step : -step;

    const angPy = bestAngle(angleX, angleY+probe);
    const angMy = bestAngle(angleX, angleY-probe);
    let dy = 0;
    if (angPy < ang0 || angMy < ang0)
      dy = (angPy < angMy) ? step : -step;

    angleX += dx;
    angleY += dy;
  }

  // ---------- UPDATE HELPERS ----------
  function updateCube(){
    cubeGroup.rotation.x = THREE.MathUtils.degToRad(angleX);
    cubeGroup.rotation.y = THREE.MathUtils.degToRad(angleY);
  }

  function updateColors(){
    const gold = 0xC0B283;
    const white = 0xffffff;
    const col = isAligned(angleX,angleY) ? gold : white;
    lineMaterial.color.setHex(col);
    circleMaterial.color.setHex(col);
  }

  function updateCircles() {
    const M = rotationMatrix(angleX, angleY);

    function rotAll(arr) {
      return arr.map(v => rot(M,v));
    }

    const outW = rotAll(outerVerts);
    const inW  = rotAll(innerVerts);

    for (let i=0;i<outerCircles.length;i++) {
      const [x,y,z] = outW[i];
      outerCircles[i].position.set(x,y,z);
      outerCircles[i].quaternion.copy(camera.quaternion);
    }

    for (let i=0;i<innerCircles.length;i++) {
      const [x,y,z] = inW[i];
      innerCircles[i].position.set(x,y,z);
      innerCircles[i].quaternion.copy(camera.quaternion);
    }
  }

  // ---------- RESPONSIVE SIZE ----------
  // Portrait: 100% of width; Landscape: 75% of min(width, height)
  function onResize() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    let size;
    if (h > w) {
      size = Math.floor(w * 1.00);
    } else {
      size = Math.floor(Math.min(w, h) * 0.75);
    }

    renderer.setSize(size, size);
  }

  window.addEventListener("resize", onResize);

  // ---------- MAIN LOOP ----------
  function animate() {
    requestAnimationFrame(animate);

    if (!mouseDown && !lockedToVertex) {
      angleX += velX;
      angleY += velY;
      velX *= damping;
      velY *= damping;
    }

    applyDrift();
    updateCube();
    updateColors();
    updateCircles();

    renderer.render(scene, camera);
  }

  onResize();
  animate();

})();
</script>

</body>
</html>