<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Spin-a-Tron</title>
  <style>
    body {
      margin: 0;
      background: #050505;
      overflow: hidden;
    }
    #metatron-container {
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
</head>
<body>
<div id="metatron-container"></div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
(function() {
  const container = document.getElementById('metatron-container');

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050505);

  // ----- ORTHOGRAPHIC CAMERA -----
  const worldSize = 3.0;
  const camera = new THREE.OrthographicCamera(
    -worldSize, worldSize,
     worldSize, -worldSize,
    0.1, 100
  );
  camera.position.set(0, 0, 5);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  container.appendChild(renderer.domElement);

  // ----- GLOBAL ROTATION + INERTIA -----
  let angleX = 30.0;   
  let angleY = 30.0;

  const mouseSensitivity = 0.4;
  let mouseDown = false;
  let lastMouseX = null;
  let lastMouseY = null;

  let velX = 0;
  let velY = 0;
  const damping = 0.92;

  let lockedToVertex = false;

  // ----- TOUCH DETECTION -----
  const isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

  // ----- GEOMETRY -----
  const baseVertices = [
    [-1,-1,-1],[1,-1,-1],
    [1,1,-1],[-1,1,-1],
    [-1,-1,1],[1,-1,1],
    [1,1,1],[-1,1,1]
  ];

  const cubeEdges = [
    [0,1],[1,2],[2,3],[3,0],
    [4,5],[5,6],[6,7],[7,4],
    [0,4],[1,5],[2,6],[3,7]
  ];

  const cubeFaces = [
    [0,1,2,3],[4,5,6,7],
    [0,1,5,4],[3,2,6,7],
    [0,3,7,4],[1,2,6,5]
  ];

  const cubeScales = [1.0, 1/Math.sqrt(2), 0.5];
  const outerScale = cubeScales[0];
  const innerScale = cubeScales[2];

  function scaledVertices(scale) {
    return baseVertices.map(([x,y,z]) => [x*scale,y*scale,z*scale]);
  }

  function faceCenters(vertices) {
    const centers = [];
    for (const f of cubeFaces) {
      let sx=0,sy=0,sz=0;
      for (const i of f) { const v = vertices[i]; sx+=v[0]; sy+=v[1]; sz+=v[2]; }
      centers.push([sx/4,sy/4,sz/4]);
    }
    return centers;
  }

  // ----- BUILD GEOMETRY -----
  const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
  const allPositions = [];

  function addCube(scale) {
    const v = scaledVertices(scale);
    for (const [a,b] of cubeEdges) {
      const A=v[a],B=v[b];
      allPositions.push(A[0],A[1],A[2], B[0],B[1],B[2]);
    }
    for (const f of cubeFaces) {
      const [a,b,c,d] = f;
      const A=v[a],B=v[b],C=v[c],D=v[d];
      allPositions.push(A[0],A[1],A[2], C[0],C[1],C[2]);
      allPositions.push(B[0],B[1],B[2], D[0],D[1],D[2]);
    }
  }

  function addOctahedron() {
    const v = scaledVertices(outerScale);
    const centers = faceCenters(v);
    const opp = {0:1,1:0,2:3,3:2,4:5,5:4};

    for (let i=0;i<6;i++)
      for (let j=i+1;j<6;j++)
        if (opp[i]!==j) {
          const A=centers[i],B=centers[j];
          allPositions.push(A[0],A[1],A[2], B[0],B[1],B[2]);
        }
  }

  function addPyramids() {
    const v = scaledVertices(outerScale);
    const centers = faceCenters(v);
    const opp = {0:1,1:0,2:3,3:2,4:5,5:4};

    for (let i=0;i<6;i++) {
      const face=cubeFaces[i];
      const apex=centers[opp[i]];
      for (const vi of face) {
        const A=v[vi];
        allPositions.push(A[0],A[1],A[2], apex[0],apex[1],apex[2]);
      }
    }
  }

  addCube(outerScale);
  addOctahedron();
  addPyramids();

  const lineGeom=new THREE.BufferGeometry();
  lineGeom.setAttribute("position", new THREE.Float32BufferAttribute(allPositions,3));
  const lineMesh=new THREE.LineSegments(lineGeom,lineMaterial);

  const cubeGroup=new THREE.Group();
  cubeGroup.add(lineMesh);
  scene.add(cubeGroup);

  // ----- BILLBOARD CIRCLES -----
  const circleMaterial=new THREE.LineBasicMaterial({color:0xffffff});
  const circleRadius=0.4;
  const circleSeg=96;

  function circleGeom(r,seg) {
    const pts=[];
    for(let i=0;i<seg;i++){
      const t=2*Math.PI*i/seg;
      pts.push(r*Math.cos(t),r*Math.sin(t),0);
    }
    const g=new THREE.BufferGeometry();
    g.setAttribute("position",new THREE.Float32BufferAttribute(pts,3));
    return g;
  }

  const circGeom=circleGeom(circleRadius,circleSeg);

  const outerVerts = scaledVertices(outerScale);
  const innerVerts = scaledVertices(innerScale);
  const faceCentersOuter = faceCenters(outerVerts);

  const outerCircles=[], innerCircles=[];
  for(let i=0;i<outerVerts.length;i++){
    const c=new THREE.LineLoop(circGeom,circleMaterial);
    scene.add(c); outerCircles.push(c);
  }
  for(let i=0;i<innerVerts.length;i++){
    const c=new THREE.LineLoop(circGeom,circleMaterial);
    scene.add(c); innerCircles.push(c);
  }

  // ----- ALIGNMENT MATH -----
  function rotationMatrix(ax,ay){
    const AX=THREE.MathUtils.degToRad(ax);
    const AY=THREE.MathUtils.degToRad(ay);
    const sx=Math.sin(AX), cx=Math.cos(AX);
    const sy=Math.sin(AY), cy=Math.cos(AY);
    return [
      [ cy,0,-sy ],
      [ sy*sx,cx,cy*sx ],
      [ sy*cx,-sx,cy*cx ]
    ];
  }

  function rot(M,v){
    const x=v[0],y=v[1],z=v[2];
    return [
      M[0][0]*x+M[0][1]*y+M[0][2]*z,
      M[1][0]*x+M[1][1]*y+M[1][2]*z,
      M[2][0]*x+M[2][1]*y+M[2][2]*z
    ];
  }

  function bestAngle(ax,ay){
    const M=rotationMatrix(ax,ay);
    let best=Infinity;

    function process(v){
      let [x,y,z]=rot(M,v);
      const L=Math.sqrt(x*x+y*y+z*z);
      x/=L; y/=L; z/=L;
      let dot=z; if(dot>1)dot=1; if(dot<-1)dot=-1;
      const ang=Math.acos(dot);
      if(ang<best) best=ang;
    }

    for(const v of outerVerts) process(v);
    for(const c of faceCentersOuter) process(c);
    return best;
  }

  function isAligned(ax,ay){
    return bestAngle(ax,ay)<=THREE.MathUtils.degToRad(5);
  }

  // ----- INPUT: DESKTOP POINTER -----
  renderer.domElement.addEventListener("pointerdown", e=>{
    if(isTouch) return;
    mouseDown=true;
    lastMouseX=e.clientX; lastMouseY=e.clientY;
    velX=0; velY=0;
  });

  window.addEventListener("pointerup",()=>{
    if(isTouch) return;
    mouseDown=false;
    lastMouseX=null; lastMouseY=null;
  });

  renderer.domElement.addEventListener("pointermove", e=>{
    if(isTouch) return;
    if(!mouseDown) return;
    const dx=e.clientX-lastMouseX;
    const dy=e.clientY-lastMouseY;
    lastMouseX=e.clientX; lastMouseY=e.clientY;

    const dAX=dy*mouseSensitivity;
    const dAY=dx*mouseSensitivity;

    angleX+=dAX; angleY+=dAY;
    velX=dAX*0.5; velY=dAY*0.5;
  });

  // ----- INPUT: MOBILE TOUCH -----
  renderer.domElement.addEventListener("touchstart", e=>{
    if(!isTouch) return;
    const t=e.touches[0];
    lastMouseX=t.clientX;
    lastMouseY=t.clientY;
    mouseDown=true;
    velX=0; velY=0;
  }, {passive:true});

  renderer.domElement.addEventListener("touchmove", e=>{
    if(!isTouch) return;
    const t=e.touches[0];
    const dx=t.clientX-lastMouseX;
    const dy=t.clientY-lastMouseY;
    lastMouseX=t.clientX;
    lastMouseY=t.clientY;

    const dAX=dy*mouseSensitivity;
    const dAY=dx*mouseSensitivity;

    angleX+=dAX; angleY+=dAY;
    velX=dAX*0.5; velY=dAY*0.5;
  }, {passive:true});

  renderer.domElement.addEventListener("touchend",()=>{
    if(!isTouch) return;
    mouseDown=false;
    lastMouseX=null;
    lastMouseY=null;
  });

  // ----- DRIFT (15°→0°) WITH LOCK -----
  function applyDrift(){
    const ang0=bestAngle(angleX,angleY);
    const lockTh=THREE.MathUtils.degToRad(0.5);
    const maxActive=THREE.MathUtils.degToRad(15);

    if(lockedToVertex){
      if(ang0>=maxActive) lockedToVertex=false;
      else return;
    }

    if(ang0<=lockTh){
      velX=0; velY=0;
      lockedToVertex=true;
      return;
    }

    if(ang0>=maxActive) return;

    const probe=0.5, step=0.6;

    const angPx=bestAngle(angleX+probe,angleY);
    const angMx=bestAngle(angleX-probe,angleY);
    let dx=0;
    if(angPx<ang0 || angMx<ang0)
      dx=(angPx<angMx)?step:-step;

    const angPy=bestAngle(angleX,angleY+probe);
    const angMy=bestAngle(angleX,angleY-probe);
    let dy=0;
    if(angPy<ang0 || angMy<ang0)
      dy=(angPy<angMy)?step:-step;

    angleX+=dx;
    angleY+=dy;
  }

  // ----- UPDATES -----
  function updateCube(){
    cubeGroup.rotation.x=THREE.MathUtils.degToRad(angleX);
    cubeGroup.rotation.y=THREE.MathUtils.degToRad(angleY);
  }

  function updateColors(){
    const gold=0xC0B283;
    const white=0xffffff;
    const col=isAligned(angleX,angleY)?gold:white;
    lineMaterial.color.setHex(col);
    circleMaterial.color.setHex(col);
  }

  function updateCircles(){
    const M=rotationMatrix(angleX,angleY);

    function rotAll(arr){
      return arr.map(v=>rot(M,v));
    }
    const outW=rotAll(outerVerts);
    const inW =rotAll(innerVerts);

    for(let i=0;i<outerCircles.length;i++){
      const [x,y,z]=outW[i];
      outerCircles[i].position.set(x,y,z);
      outerCircles[i].quaternion.copy(camera.quaternion);
    }
    for(let i=0;i<innerCircles.length;i++){
      const [x,y,z]=inW[i];
      innerCircles[i].position.set(x,y,z);
      innerCircles[i].quaternion.copy(camera.quaternion);
    }
  }

  // ----- RESPONSIVE 75% SQUARE -----
  function onResize() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    // If the window is taller than wide → cube = 90% of width
    // Otherwise → cube = 75% of min dimension (your previous rule)
    let size;
    if (h > w) {
      size = Math.floor(w * 1.0);
    } else {
      size = Math.floor(Math.min(w, h) * 0.75);
    }

    renderer.setSize(size, size);
  }
  window.addEventListener("resize",onResize);

  // ----- ANIMATION LOOP -----
  function animate(){
    requestAnimationFrame(animate);

    if(!mouseDown && !lockedToVertex){
      angleX+=velX;
      angleY+=velY;
      velX*=damping;
      velY*=damping;
    }

    applyDrift();
    updateCube();
    updateColors();
    updateCircles();

    renderer.render(scene,camera);
  }

  onResize();
  animate();
})();
</script>
</body>
</html>
