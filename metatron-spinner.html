<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Metatron Spinner</title>
  <style>
    body { margin: 0; background: #050505; }
    #metatron-container {
      width: 800px;
      height: 800px;
      margin: 0 auto;
      display: block;
    }
  </style>
</head>
<body>
<div id="metatron-container"></div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
(function() {
  const container = document.getElementById('metatron-container');

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050505);

  // ----- ORTHOGRAPHIC CAMERA (matches glOrtho-ish) -----
  const size = 3.0;
  function makeOrthoCamera() {
    const aspect = container.clientWidth / container.clientHeight;
    let left, right, top, bottom;
    if (aspect >= 1.0) {
      left = -size * aspect;
      right =  size * aspect;
      top =  size;
      bottom = -size;
    } else {
      left = -size;
      right =  size;
      top =  size / aspect;
      bottom = -size / aspect;
    }
    const cam = new THREE.OrthographicCamera(left, right, top, bottom, 0.1, 100);
    cam.position.set(0, 0, 5);  // like glTranslatef(0,0,-5)
    cam.lookAt(0, 0, 0);
    return cam;
  }

  let camera = makeOrthoCamera();

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  // ----- Global orientation + inertia state -----
  let angleX = 30.0;   // degrees
  let angleY = 30.0;   // degrees

  const mouseSensitivity = 0.4;
  let lastMouseX = null;
  let lastMouseY = null;
  let mouseDown = false;

  // inertia (deg per frame)
  let velX = 0.0;
  let velY = 0.0;
  const damping = 0.92;  // inertia slowdown

  // vertex/face-locking state
  let lockedToVertex = false;

  // ----- Cube geometry data -----
  const baseVertices = [
    [-1., -1., -1.], [ 1., -1., -1.],
    [ 1.,  1., -1.], [-1.,  1., -1.],
    [-1., -1.,  1.], [ 1., -1.,  1.],
    [ 1.,  1.,  1.], [-1.,  1.,  1.],
  ];

  const cubeEdges = [
    [0,1],[1,2],[2,3],[3,0],
    [4,5],[5,6],[6,7],[7,4],
    [0,4],[1,5],[2,6],[3,7]
  ];

  const cubeFaces = [
    [0,1,2,3], // 0 back
    [4,5,6,7], // 1 front
    [0,1,5,4], // 2 bottom
    [3,2,6,7], // 3 top
    [0,3,7,4], // 4 left
    [1,2,6,5]  // 5 right
  ];

  const cubeScales = [1.0, 1.0 / Math.sqrt(2.0), 0.5];  // outer, mid, inner (mid unused now)

  function scaledVertices(scale) {
    return baseVertices.map(([x,y,z]) => [x*scale, y*scale, z*scale]);
  }

  function faceCenters(vertices) {
    const centers = [];
    for (const face of cubeFaces) {
      let sx=0, sy=0, sz=0;
      for (const idx of face) {
        const v = vertices[idx];
        sx += v[0]; sy += v[1]; sz += v[2];
      }
      centers.push([sx/4, sy/4, sz/4]);
    }
    return centers;
  }

  // ----- Build line geometry: outer cube + diagonals + octahedron + pyramids -----
  const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });

  function addCubeWire(scale, positionArray) {
    const v = scaledVertices(scale);
    for (const [a,b] of cubeEdges) {
      const va = v[a], vb = v[b];
      positionArray.push(va[0],va[1],va[2], vb[0],vb[1],vb[2]);
    }
  }

  function addFaceDiagonals(scale, positionArray) {
    const v = scaledVertices(scale);
    for (const f of cubeFaces) {
      const [a,b,c,d] = f;
      const va = v[a], vb = v[b], vc = v[c], vd = v[d];
      positionArray.push(va[0],va[1],va[2], vc[0],vc[1],vc[2]);
      positionArray.push(vb[0],vb[1],vb[2], vd[0],vd[1],vd[2]);
    }
  }

  function addCubeWithDiagonals(scale, positionArray) {
    addCubeWire(scale, positionArray);
    addFaceDiagonals(scale, positionArray);
  }

  // Octahedron whose vertices are centers of the faces of the outer cube
  function addOctahedron(scaleOuter, positionArray) {
    const vOuter = scaledVertices(scaleOuter);
    const centers = faceCenters(vOuter); // 6 centers

    // Opposites: 0-1, 2-3, 4-5
    const opposites = {0:1, 1:0, 2:3, 3:2, 4:5, 5:4};

    for (let i = 0; i < centers.length; i++) {
      for (let j = i+1; j < centers.length; j++) {
        if (opposites[i] === j) continue; // skip opposite faces
        const a = centers[i];
        const b = centers[j];
        positionArray.push(a[0],a[1],a[2], b[0],b[1],b[2]);
      }
    }
  }

  // Pyramids: for each face, base is that face's vertices, apex is center of opposite face
  function addPyramids(scaleOuter, positionArray) {
    const vOuter = scaledVertices(scaleOuter);
    const centers = faceCenters(vOuter);

    const opposites = {0:1, 1:0, 2:3, 3:2, 4:5, 5:4};

    for (let fi = 0; fi < cubeFaces.length; fi++) {
      const face = cubeFaces[fi];
      const apex = centers[opposites[fi]];
      for (const vi of face) {
        const v = vOuter[vi];
        positionArray.push(v[0], v[1], v[2], apex[0], apex[1], apex[2]);
      }
    }
  }

  const allPositions = [];
  const outerScale = cubeScales[0];
  const innerScale = cubeScales[2];

  addCubeWithDiagonals(outerScale, allPositions);
  addOctahedron(outerScale, allPositions);
  addPyramids(outerScale, allPositions);

  const lineGeom = new THREE.BufferGeometry();
  lineGeom.setAttribute('position', new THREE.Float32BufferAttribute(allPositions, 3));
  const lineMesh = new THREE.LineSegments(lineGeom, lineMaterial);

  const cubeGroup = new THREE.Group();
  cubeGroup.add(lineMesh);
  scene.add(cubeGroup);

  // ----- Billboard circles on vertices (outer + inner only) -----
  const circleMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
  const circleRadius = 0.4;
  const circleSegments = 96;

  function createCircleGeometry(radius, segments) {
    const pts = [];
    for (let i = 0; i < segments; i++) {
      const t = 2 * Math.PI * i / segments;
      pts.push(radius * Math.cos(t), radius * Math.sin(t), 0);
    }
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
    return geom;
  }

  const circleGeom = createCircleGeometry(circleRadius, circleSegments);

  const outerVertexLocal = scaledVertices(outerScale);
  const innerVertexLocal = scaledVertices(innerScale);
  const outerFaceCenterLocal = faceCenters(outerVertexLocal); // for alignment

  const outerCircles = [];
  const innerCircles = [];

  for (let i = 0; i < outerVertexLocal.length; i++) {
    const circle = new THREE.LineLoop(circleGeom, circleMaterial);
    scene.add(circle);
    outerCircles.push(circle);
  }
  for (let i = 0; i < innerVertexLocal.length; i++) {
    const circle = new THREE.LineLoop(circleGeom, circleMaterial);
    scene.add(circle);
    innerCircles.push(circle);
  }

  // ----- Angle / drift logic (vertices + face centers) -----

  function rotationMatrix(axDeg, ayDeg) {
    const ax = THREE.MathUtils.degToRad(axDeg);
    const ay = THREE.MathUtils.degToRad(ayDeg);
    const sx = Math.sin(ax), cx = Math.cos(ax);
    const sy = Math.sin(ay), cy = Math.cos(ay);
    return [
      [ cy,        0.0,   -sy     ],
      [ sy*sx,     cx,    cy*sx   ],
      [ sy*cx,    -sx,    cy*cx   ]
    ];
  }

  function rotateVec(M, v) {
    const x = v[0], y = v[1], z = v[2];
    return [
      M[0][0]*x + M[0][1]*y + M[0][2]*z,
      M[1][0]*x + M[1][1]*y + M[1][2]*z,
      M[2][0]*x + M[2][1]*y + M[2][2]*z
    ];
  }

  // Now consider BOTH vertex directions and face-center directions
  function bestAlignmentAngle(axDeg, ayDeg) {
    const M = rotationMatrix(axDeg, ayDeg);
    let bestAng = Infinity;

    function processVec(v) {
      let [vx,vy,vz] = rotateVec(M, v);
      const L = Math.sqrt(vx*vx + vy*vy + vz*vz);
      vx /= L; vy /= L; vz /= L;
      let dotp = vz; // dot with (0,0,1)
      if (dotp > 1) dotp = 1;
      if (dotp < -1) dotp = -1;
      const ang = Math.acos(dotp);
      if (ang < bestAng) bestAng = ang;
    }

    for (const v of outerVertexLocal) {
      processVec(v);
    }
    for (const c of outerFaceCenterLocal) {
      processVec(c);
    }

    return bestAng;
  }

  function isGreen(axDeg, ayDeg) {
    const ang = bestAlignmentAngle(axDeg, ayDeg);
    return ang <= THREE.MathUtils.degToRad(5);
  }

  // ----- Mouse handling (relative) + inertia injection -----
  renderer.domElement.addEventListener('pointerdown', (e) => {
    mouseDown = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    velX = 0;
    velY = 0;
  });
  window.addEventListener('pointerup', () => {
    mouseDown = false;
    lastMouseX = null;
    lastMouseY = null;
  });
  window.addEventListener('pointerleave', () => {
    mouseDown = false;
    lastMouseX = null;
    lastMouseY = null;
  });

  renderer.domElement.addEventListener('pointermove', (e) => {
    if (!mouseDown) return;
    if (lastMouseX === null || lastMouseY === null) {
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      return;
    }
    const dx = e.clientX - lastMouseX;
    const dy = e.clientY - lastMouseY;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;

    const dAX = dy * mouseSensitivity;
    const dAY = dx * mouseSensitivity;

    angleX += dAX;
    angleY += dAY;

    velX = dAX * 0.5;
    velY = dAY * 0.5;
  });

  // ----- Drift (15° → 0°) with vertex/face lock -----

  function applyDrift() {
    const ang0 = bestAlignmentAngle(angleX, angleY);

    const lockThreshold = THREE.MathUtils.degToRad(0.5); // ~"exactly 0°"
    const maxActive     = THREE.MathUtils.degToRad(15);  // area of influence upper bound

    if (lockedToVertex) {
      if (ang0 >= maxActive) {
        lockedToVertex = false; // left the influence cone
      } else {
        return; // locked and still inside influence → no drift, no jitter
      }
    }

    if (ang0 <= lockThreshold) {
      velX = 0;
      velY = 0;
      lockedToVertex = true;
      return;
    }

    if (ang0 >= maxActive) {
      return;
    }

    const probeStep = 0.5;
    const moveStep  = 0.6;

    const angPx = bestAlignmentAngle(angleX + probeStep, angleY);
    const angMx = bestAlignmentAngle(angleX - probeStep, angleY);
    let dx = 0.0;
    if (angPx < ang0 || angMx < ang0) {
      dx = (angPx < angMx) ? moveStep : -moveStep;
    }

    const angPy = bestAlignmentAngle(angleX, angleY + probeStep);
    const angMy = bestAlignmentAngle(angleX, angleY - probeStep);
    let dy = 0.0;
    if (angPy < ang0 || angMy < ang0) {
      dy = (angPy < angMy) ? moveStep : -moveStep;
    }

    if (dx !== 0.0 || dy !== 0.0) {
      angleX += dx;
      angleY += dy;
    }
  }

  function updateCubeTransform() {
    cubeGroup.rotation.x = THREE.MathUtils.degToRad(angleX);
    cubeGroup.rotation.y = THREE.MathUtils.degToRad(angleY);
  }

  function updateColors() {
    const green = isGreen(angleX, angleY);
    const color = green ? 0x00ff00 : 0xffffff;
    lineMaterial.color.setHex(color);
    circleMaterial.color.setHex(color);
  }

  function updateCircles() {
    const M = rotationMatrix(angleX, angleY);

    function transformedVertices(localVerts) {
      return localVerts.map((v) => rotateVec(M, v));
    }

    const outerWorld = transformedVertices(outerVertexLocal);
    const innerWorld = transformedVertices(innerVertexLocal);

    for (let i = 0; i < outerCircles.length; i++) {
      const [x,y,z] = outerWorld[i];
      outerCircles[i].position.set(x, y, z);
      outerCircles[i].quaternion.copy(camera.quaternion); // billboard
    }

    for (let i = 0; i < innerCircles.length; i++) {
      const [x,y,z] = innerWorld[i];
      innerCircles[i].position.set(x, y, z);
      innerCircles[i].quaternion.copy(camera.quaternion);
    }
  }

  function onResize() {
    const w = container.clientWidth;
    const h = container.clientHeight;
    renderer.setSize(w, h);

    const aspect = w / h;
    let left, right, top, bottom;
    if (aspect >= 1.0) {
      left = -size * aspect;
      right =  size * aspect;
      top =  size;
      bottom = -size;
    } else {
      left = -size;
      right =  size;
      top =  size / aspect;
      bottom = -size / aspect;
    }
    camera.left = left;
    camera.right = right;
    camera.top = top;
    camera.bottom = bottom;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onResize);

  function animate() {
    requestAnimationFrame(animate);

    if (!mouseDown && !lockedToVertex) {
      angleX += velX;
      angleY += velY;
      velX *= damping;
      velY *= damping;
    }

    applyDrift();
    updateCubeTransform();
    updateColors();
    updateCircles();

    renderer.render(scene, camera);
  }

  onResize();
  animate();
})();
</script>
</body>
</html>
